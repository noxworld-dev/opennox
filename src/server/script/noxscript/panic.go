package noxscript

import (
	"encoding/binary"

	"nox/v1/common/log"
)

func (r *Runtime) PanicsCompilerEnabled() bool {
	return r.panicsCompiler
}

func (r *Runtime) checkPanicCompiler(fnc int) bool {
	// ===[ Panic's compiler detection ]===
	// it usually triggers on a2=973231
	// 0x587000 + 245900 + 3892924 -> 0x979748 -> 0x5D4594 + 3821996 + 8 -> nox_script_stack[2]

	off := 0x587000 + 245900 + 4*fnc
	stackOff := off - (0x5D4594 + 3821996)

	if stackOff < 0 || stackOff+4 > 4096 || stackOff%4 != 0 {
		return false // disallow other type of stack manipulation
	}
	stackInd := stackOff / 4
	// function address we need to jump to
	// basically points to the following uint32 on the stack
	if r.StackAt(stackInd) != 0x97974c {
		return false
	}
	stackInd++

	stackExp := []byte{
		0x56, // push   esi
		// -> 0x5D4594 + 1558936 + 356 (safe location in a string buffer?)
		0xbe, 0x90, 0x10, 0x75, 0x00, // mov    esi,0x751090
		// inject two functions there, see in replaced functions
		0xc7, 0x06, 0x68, 0x50, 0x72, 0x50, // mov    DWORD PTR [esi],0x50725068
		0xc7, 0x46, 0x04, 0x00, 0x68, 0x30, 0x72, // mov    DWORD PTR [esi+0x4],0x72306800
		0xc7, 0x46, 0x08, 0x50, 0x00, 0xff, 0x54, // mov    DWORD PTR [esi+0x8],0x54ff0050
		0xc7, 0x46, 0x0c, 0x24, 0x04, 0xff, 0x30, // mov    DWORD PTR [esi+0xc],0x30ff0424
		0xc7, 0x46, 0x10, 0xff, 0x54, 0x24, 0x04, // mov    DWORD PTR [esi+0x10],0x42454ff
		0xc7, 0x46, 0x14, 0x83, 0xc4, 0x0c, 0x31, // mov    DWORD PTR [esi+0x14],0x310cc483
		0xc7, 0x46, 0x18, 0xc0, 0xc3, 0x90, 0x90, // mov    DWORD PTR [esi+0x18],0x9090c3c0
		0xc7, 0x46, 0x1c, 0x56, 0x68, 0x50, 0x72, // mov    DWORD PTR [esi+0x1c],0x72506856
		0xc7, 0x46, 0x20, 0x50, 0x00, 0xff, 0x14, // mov    DWORD PTR [esi+0x20],0x14ff0050
		0xc7, 0x46, 0x24, 0x24, 0x8b, 0xf0, 0xff, // mov    DWORD PTR [esi+0x24],0xfff08b24
		0xc7, 0x46, 0x28, 0x14, 0x24, 0x89, 0x30, // mov    DWORD PTR [esi+0x28],0x30892414
		0xc7, 0x46, 0x2c, 0x83, 0xc4, 0x04, 0x5e, // mov    DWORD PTR [esi+0x2c],0x5e04c483
		0xc7, 0x46, 0x30, 0xc3, 0x90, 0x90, 0x90, // mov    DWORD PTR [esi+0x30],0x909090c3
		// override opcode 185 from nox_script_builtin_516850 to new func 1
		0x89, 0x35, 0x70, 0x33, 0x5c, 0x00, // mov    DWORD PTR ds:0x5c3370,esi
		// override opcode 89 from nox_script_fn59_513F20 to new func 2
		0xc7, 0x5, 0xf0, 0x31, 0x5c, 0x00, 0xac, // mov    DWORD PTR ds:0x5c31f0,0x7510ac
		0x10, 0x75, 0x00, //
		0x5e,       // pop    esi
		0xc3,       // ret
		0x90, 0x90, // nop x2
	}
	bodyDwords := len(stackExp) / 4
	if stackInd+bodyDwords >= 1024 {
		return false // we expect all items of the body to fit
	}
	// check that the exploit code is exactly the one we expect
	for i := 0; i < bodyDwords; i++ {
		if binary.LittleEndian.Uint32(stackExp[4*i:]) != r.StackAt(stackInd+i) {
			return false
		}
	}
	r.panicsCompiler = true
	log.Printf("noxscript: enabled Panic's compiler API")
	return true
}
