package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"strconv"
)

func main() {
	fOut := flag.String("out", "ccall.go", "file to write to")
	flag.Parse()
	if err := run(*fOut); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

type Type struct {
	C      string
	CName  string
	Go     string
	GoName string

	C2GoStart string
	C2GoEnd   string

	Go2CStart string
	Go2CEnd   string
}

var (
	voidT    *Type
	uintptrT = &Type{
		C: "uintptr_t", CName: "uptr",
		Go: "uintptr", GoName: "UPtr",
		C2GoStart: "uintptr(", C2GoEnd: ")",
		Go2CStart: "C.uintptr_t(", Go2CEnd: ")",
	}
	ptrT = &Type{C: "void*", CName: "ptr", Go: "unsafe.Pointer", GoName: "Ptr"}
	intT = &Type{
		C: "int", CName: "int",
		Go: "int", GoName: "Int",
		C2GoStart: "int(", C2GoEnd: ")",
		Go2CStart: "C.int(", Go2CEnd: ")",
	}
)

func run(out string) error {
	var returns = []*Type{
		voidT,
		uintptrT,
		ptrT,
		intT,
	}
	var args = []*Type{
		uintptrT,
		ptrT,
		intT,
	}
	var (
		gbuf bytes.Buffer
		hbuf bytes.Buffer
	)

	for _, ret := range returns {
		rname := "void"
		if ret != nil {
			rname = ret.CName
		}
		rgname := "Void"
		if ret != nil {
			rgname = ret.GoName
		}
		generate(&hbuf, &gbuf, rname+"_void", rgname+"Void", ret, nil)
		for _, arg := range args {
			for n := 1; n <= 6; n++ {
				alist := make([]Type, n)
				for i := range alist {
					alist[i] = *arg
				}
				num := ""
				if n > 1 {
					num = strconv.Itoa(n)
				}
				generate(&hbuf, &gbuf, rname+"_"+arg.CName+num, rgname+arg.GoName+num, ret, alist)
			}
		}
	}

	var buf bytes.Buffer
	buf.WriteString(`// Code generated by callgen; DO NOT EDIT.

package ccall

/*
#include <stdint.h>

`)
	buf.Write(hbuf.Bytes())
	buf.WriteString(`
*/
import "C"
import "unsafe"
`)
	buf.Write(gbuf.Bytes())
	return os.WriteFile(out, buf.Bytes(), 0644)
}

func generate(h, g *bytes.Buffer, cname, goname string, ret *Type, args []Type) {
	generateHeader(h, cname, ret, args)
	generateGo(g, cname, goname, ret, args)
}

func generateHeader(w *bytes.Buffer, cname string, ret *Type, args []Type) {
	w.WriteString("static ")
	if ret == nil {
		w.WriteString("void")
	} else {
		w.WriteString(ret.C)
	}
	w.WriteString(" go_call_")
	w.WriteString(cname)
	w.WriteString("_func(")
	if ret == nil {
		w.WriteString("void")
	} else {
		w.WriteString(ret.C)
	}
	w.WriteString(" (*fnc)(")
	if len(args) == 0 {
		w.WriteString("void")
	} else {
		for i, a := range args {
			if i != 0 {
				w.WriteString(", ")
			}
			w.WriteString(a.C)
		}
	}
	w.WriteString(")")
	for i, a := range args {
		w.WriteString(", ")
		w.WriteString(a.C)
		w.WriteString(" a")
		w.WriteString(strconv.Itoa(i + 1))
	}
	w.WriteString(") { ")
	if ret != nil {
		w.WriteString("return ")
	}
	w.WriteString("fnc(")
	for i := range args {
		if i != 0 {
			w.WriteString(", ")
		}
		w.WriteString("a")
		w.WriteString(strconv.Itoa(i + 1))
	}
	w.WriteString("); }\n")
}

func generateGo(w *bytes.Buffer, cname, goname string, ret *Type, args []Type) {
	w.WriteString("\nfunc Call")
	w.WriteString(goname)
	w.WriteString("(fnc unsafe.Pointer")
	for i, a := range args {
		w.WriteString(", a")
		w.WriteString(strconv.Itoa(i + 1))
		w.WriteString(" ")
		w.WriteString(a.Go)
	}
	w.WriteString(")")
	if ret != nil {
		w.WriteString(" ")
		w.WriteString(ret.Go)
	}
	w.WriteString(" {\n\t")
	if ret != nil {
		w.WriteString("return ")
		w.WriteString(ret.C2GoStart)
	}
	w.WriteString("C.go_call_")
	w.WriteString(cname)
	w.WriteString("_func((*[0]byte)(fnc)")
	for i, a := range args {
		w.WriteString(", ")
		w.WriteString(a.Go2CStart)
		w.WriteString("a")
		w.WriteString(strconv.Itoa(i + 1))
		w.WriteString(a.Go2CEnd)
	}
	w.WriteString(")")
	if ret != nil {
		w.WriteString(ret.C2GoEnd)
	}
	w.WriteString("\n")
	w.WriteString("}\n")
}
